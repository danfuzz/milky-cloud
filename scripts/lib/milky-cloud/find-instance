#!/bin/bash
#
# Copyright 2022-2023 the Milky-cloud Authors (Dan Bornstein et alia).
# SPDX-License-Identifier: Apache-2.0

. "$(dirname "$(readlink -f "$0")")/_init.sh" || exit "$?"


#
# Argument parsing
#

define-usage $'
    ${name} [<opt> ...] <name-or-id>

    Finds one or more instances by name or ID, with optional extra criteria, and
    prints some information about them. <name-or-id> accepts `*` as a wildcard
    character.

    --expired
      Limit the results to expired instances only.
    --loc=<region-or-zone>
      Where to look. Must be specified.
    --multiple
      Allow multiple matching instances. When specified and when using JSON
      output, the result is a JSON array instead of a single object.
    --not-found-ok
      Do not report an error if there are no matching instances. Instead, print
      nothing or an empty JSON array (as appropriate, per specified options).
    --output=<style> :: `compact` `id` `json`
      What to output, as with `json-val`, except that `id` prints just the ID
      of the VPC as a plain string. `id` is the default.
    --terminated-ok
      Match instances that are terminated. By default, these are excluded.
    --vpc=<name-or-id>
      VPC where the instance must reside, named as with `find-vpc` (see which).
      If not specified, then this command will find an instance in any VPC (in
      the given location).

    ${name} [--help | -h]

    Displays this message.
'

# Want help?
opt-action --call='{ usage; exit }' help/h

# Expired instances only?
opt-toggle --var=expiredOnly expired

# Location (region or availability zone).
opt-value --required --var=location --filter='/[-a-z0-9]+/' loc

# Multiple results?
opt-toggle --var=multipleResults multiple

# Ok if no instance found?
opt-toggle --var=notFoundOk not-found-ok

# What to print.
opt-value --var=outputStyle --init=id --enum='compact id json' output

# Show terminated instances?
opt-toggle --var=terminatedOk terminated-ok

# VPC to require.
opt-value --var=vpcNameOrId --filter='/./' vpc

# Name or ID to look up.
positional-arg --required --var=nameOrId name-or-id

process-args "$@" || usage --short


#
# Helper functions
#

# Filter the given list of instance info, returning only info on expired
# instances.
function filter-expired {
    local infoJson="$1"

    local nowSecs="$(lib timey now-secs)"

    jget "${infoJson}" \
        nowSecs:json="${nowSecs}" '
        map(select(
              ((.expiredAfter // "") | match("^[0-9]+").string | fromjson)
                as $expiredAfter
            |
              $expiredAfter <= $nowSecs
        ))
    '
}


#
# Main script
#

locJson="$(lib parse-location --output=json "${location}")" \
|| exit "$?"
region="$(jget --output=raw "${locJson}" '.region')"
zone="$(jget --output=raw "${locJson}" '.zone // ""')"

instanceId=
instanceName=
if [[ ${nameOrId} =~ ^i-[*0-9a-f]+$ ]]; then
    instanceId="${nameOrId}"
else
    instanceName="${nameOrId}"
fi

vpcId=
if [[ ${vpcNameOrId} != '' ]]; then
    vpcId="$(lib find-vpc --loc="${location}" "${vpcNameOrId}")" \
    || exit "$?"
fi

filters=()
if [[ ${instanceId} != '' ]]; then
    filters+=(instance-id="${instanceId}")
fi
if [[ ${instanceName} != '' ]]; then
    filters+=(tag:Name="${instanceName}")
fi
if [[ ${vpcId} != '' ]]; then
    filters+=(vpc-id="${vpcId}")
fi
if [[ ${zone} != '' ]]; then
    filters+=(availability-zone="${zone}")
fi
if (( expiredOnly )); then
    # Will limit results to those with the tag, but then we have to filter
    # based on the actual tag value.
    filters+=(tag-key='expired-after')
fi

resultArray="$(ec2-json describe-instances --loc="${location}" \
    "$(lib filter-spec "${filters[@]}")" \
    :: \
        region="${region}" '
    [.Reservations[].Instances[] | {
        hostPublicKey:  (.Tags | map(select(.Key == "host-public-key") | .Value)[0]),
        id:             .InstanceId,
        ipv6Address:    (.NetworkInterfaces[].Ipv6Addresses[0].Ipv6Address),
        name:           (.Tags | map(select(.Key == "Name") | .Value)[0]),
        nameDotRegion:  "filled-in-below",
        privateAddress: .PrivateIpAddress,
        publicAddress:  .PublicIpAddress,
        region:         $region,
        state:          .State.Name,
        subnet:         .SubnetId,
        expiredAfter:   (.Tags | map(select(.Key == "expired-after") | .Value)[0]),
        vpc:            .VpcId,
        zone:           .Placement.AvailabilityZone
    } |
    .nameDotRegion = .name + "." + $region
    ]'
)" \
|| exit "$?"

if (( !terminatedOk )); then
    # It's more straightforward to filter out terminated instances as a
    # post-processing step than to try to construct a filter for them, because
    # the AWS API doesn't have a way to say "not this value" in its filters.
    resultArray="$(jget "${resultArray}" \
        'map(select(.state != "terminated"))')" \
    || exit "$?"
fi

if (( expiredOnly )); then
    # Similar reasoning to above.
    resultArray="$(filter-expired "${resultArray}")" \
    || exit "$?"
fi

resultLength="$(jlength "${resultArray}")" \
|| exit "$?"

if (( (resultLength == 0) && !notFoundOk )); then
    error-msg 'No matching instances found.'
    exit 1
elif (( (resultLength > 1) && !multipleResults )); then
    error-msg 'Ambiguous search matches all of:'
    error-msg --exec jget --output=raw "${resultArray}" '.[] | "  " + .id'
    exit 1
fi

case "${outputStyle}" in
    id)
        jget --output=raw "${resultArray}" '.[] | .id'
        ;;
    compact|json)
        if (( multipleResults )); then
            jget --output="${outputStyle}" "${resultArray}"
        else
            jget --output="${outputStyle}" "${resultArray}" '.[0] // empty'
        fi
        ;;
    *)
        error-msg "Unrecognized output style: ${output}"
        exit 1
        ;;
esac
