#!/bin/bash
#
# Copyright 2022-2023 the Milk-prod Authors (Dan Bornstein et alia).
# This project is PROPRIETARY and UNLICENSED.

. "$(dirname "$(readlink -f "$0")")/_init.sh" || exit "$?"


#
# Argument parsing
#

define-usage $'
    ${name} [<opt> ...] <binding> ...

    Adds, merges, or replaces one or more DNS records. Prints out JSON information
    about the DNS change which was created as a result.

    Note: This command only handles regular DNS records, and not aliases or
    other AWS-specific stuff.

    <binding>
      [<name>:]<type>=<value> -- Create a record of the given type with the
        given value. With `<name>`, uses that as the name-and-subdomain; without
        it, then the `--name` option provides the name to bind. It is valid to
        repeat the same name and type multiple times; this indicates a
        multi-valued record.

    --domain=<name-or-id>
      Main domain to operate on. Can be either a domain name per se or a Zone ID.
      Required.
    --name=<name>
      Name and subdomain (but not main domain name) to operate on, for <binding>s
      that don\'t specify one. Use `.` to indicate an apex record. Required if
      any <binding>s do not include a name.
    --merge
      Merges records, keeping old values for a given name/type, and just adding
      to them. Without this option, existing records are replaced (and
      nonexistent records are created).
    --[no-]wait
      Wait for the DNS records to be synchronized? `--wait` is the default.

    ${name} [--help | -h]

    Displays this message.
'

# Want help?
opt-action --call='{ usage; exit }' help/h

# TODO: Handle usual output arguments. It's hard here because we also take
# other rest args.

# Domain to operate on.
opt-value --required --var=domain --filter='/^[-./a-zA-Z0-9]+$/' domain

# Name to operate on by default.
opt-value --var=name --filter='/^[-_.a-z0-9]+$/' name

# Merge instead of replace?
opt-toggle --var=doMerge merge

# List of bindings, as parallel arrays of name, type, and value.
bindNames=()
bindTypes=()
bindValues=()

rest-arg --call=parse-bindings bindings
function parse-bindings {
    local arg
    local error=0

    while (( $# > 0 )); do
        arg="$1"
        shift

        if ! [[ ${arg} =~ ^([-_.a-zA-Z0-9]+:)?([a-z]+)=(.+)$ ]]; then
            error-msg 'Could not parse binding:' "${arg}"
            error=1
            continue
        fi

        bindNames+=("${BASH_REMATCH[1]%:}") # `%:` to remove the trailing colon.
        bindTypes+=("${BASH_REMATCH[2]}")
        bindValues+=("${BASH_REMATCH[3]}")
    done

    return "${error}"
}

process-args "$@" || usage --short


#
# Helper functions
#

# Retrieves all existing records associated with any name/type mentioned in the
# <bindings>. This is needed when merging.
function get-existing-records {
    local zoneId="$1"
    local treeJson="$2"

    local result
    result="$(lib aws-json route53 list-resource-record-sets --global \
        zoneId="${zoneId}" '{ HostedZoneId: $zoneId }' \
        :: \
        tree:json="${treeJson}" '

        def doExtract:
            ($tree | keys) as $names
            |
            map(
                .Name as $name
                |
                .Type as $type
                |
                select($tree[$name][$type] != null)
                |
                {
                    name:   .Name,
                    type:   .Type,
                    values: (.ResourceRecords | map(.Value))
                }
            )
            |
            # This forms the tree.
            reduce .[] as $item (null; .[$item.name][$item.type] += $item.values)
        ;

        if .IsTruncated == true then
            "truncated"
        else
            .ResourceRecordSets | doExtract
        end
        '
    )" \
    || exit "$?"

    if [[ ${existingJson} == '"truncated"' ]]; then
        error-msg 'Cannot handle truncated response from Route53. Sorry!'
        return 1
    fi

    echo "${result}"
}

# Makes a tree out of the parallel arrays that define the bindings. The result
# is along the lines of the following, and note that the names are fully
# expanded and types are upcased:
#
# ```
# {
#   "florp.murtbo.net.": {
#     "TXT": [
#       "\"one\"",
#       "\"two\""
#     ]
#   },
#   "murtbo.net.": {
#     "A": [
#       "10.1.2.3"
#     ],
#     "AAAA": [
#       "10::10"
#     ]
#   }
# }
# ```
function make-binding-tree {
    local domain="$1"
    local namesJson="$2"
    local typesJson="$3"
    local valuesJson="$4"

    jval \
        domain="${domain}" \
        names:json="${namesJson}" \
        types:json="${typesJson}" \
        values:json="${valuesJson}" '

        def makeName($name):
            if $name == "." then "\($domain)." else "\($name).\($domain)." end;
        [$names, $types, $values]
        |
        transpose
        |
        map({
            name:  makeName(.[0]),
            type:  (.[1] | ascii_upcase),
            value: .[2]
        })
        |
        # This produces an object which maps names to an object that maps types to
        # arrays of values.
        reduce .[] as $item (null; .[$item.name][$item.type] += [$item.value])
    '
}

# Merges two trees (per above) together, producing value arrays that contain the
# union of values of the two at each corresponding element.
function merge-trees {
    local tree1="$1"
    local tree2="$2"

    jval \
        tree1:json="${tree1}" \
        tree2:json="${tree2}" '
        def merge($v1; $v2):

            def mergeArrays($v1; $v2):
                ($v1 + $v2) | unique
            ;

            def mergeObjects($v1; $v2):
                reduce ($v2 | to_entries[]) as { key: $key, value: $sub2 } (
                    $v1;
                    . as $soFar
                    |
                    .[$key] as $sub1
                    |
                    merge($sub1; $sub2)
                    |
                    $soFar + { ($key): . }
                )
            ;

            ($v1 | type) as $type1 # Assumes same type for `$v2`.
            |
            ($v2 | type) as $type2
            |
            if $v1 == null then
                $v2
            elif $v2 == null then
                $v1
            elif $type1 != $type2 then
                halt_error("Type mismatch at (\($v1), \($v2)).")
            elif $type1 == "array" then
                mergeArrays($v1; $v2)
            elif $type1 == "object" then
                mergeObjects($v1; $v2)
            else
                halt_error("Cannot merge type \($type1) at  (\($v1), \($v2)).")
            end
        ;

        merge($tree1; $tree2)
    '
}


#
# Main script
#

# Fill in the name on any bindings that don't have one.

for n in "${!bindNames[@]}"; do
    if [[ ${bindNames[n]} == '' ]]; then
        if [[ ${name} == '' ]]; then
            error-msg 'Must supply `--name` when using nameless bindings.'
            usage --short
            exit 1
        fi
        bindNames[n]="${name}"
    fi
done

for n in "${!bindNames[@]}"; do
    info-msg "### >>${bindNames[n]}<< >>${bindTypes[n]}<< >>${bindValues[n]}<<"
done

# Look up the domain, and extract the name and ID. (We need to get the domain
# name, because the original `--domain` might have been specified as an ID.)
zoneInfo="$(lib dns find-zone --domain="${domain}")" || exit "$?"
zoneId="$(jget --output=raw "${zoneInfo}" '.id')"
domain="$(jget --output=raw "${zoneInfo}" '.name')"

# Convert bindings into a tree form.
treeJson="$(make-binding-tree "${domain}" \
    "$(jarray --input=strings "${bindNames[@]}")" \
    "$(jarray --input=strings "${bindTypes[@]}")" \
    "$(jarray --input=strings "${bindValues[@]}")"
)" \
|| exit "$?"

if (( doMerge )); then
    existingJson="$(get-existing-records "${zoneId}" "${treeJson}")" \
    || exit "$?"
    info-msg '####### EXISTING'
    jget "${existingJson}"
    info-msg '####### MERGE'
    merge-trees "${existingJson}" "${treeJson}"
    info-msg '#######'
fi


#info-msg '########## TREE'
#jget "${treeJson}"
#info-msg '##########'

# TODO: Retrieve any salient existing records (e.g. to determine add vs.
# upsert, and provide the baseline for merges).

# TODO: Make final Route53 call.

error-msg TODO
exit 1
