#!/bin/bash
#
# Copyright 2022-2023 the Milk-prod Authors (Dan Bornstein et alia).
# This project is PROPRIETARY and UNLICENSED.

. "$(dirname "$(readlink -f "$0")")/_init.sh" || exit "$?"


#
# Argument parsing
#

define-usage $'
    ${name} [<opt> ...] <binding> ...

    Adds, merges, or replaces one or more DNS records. Prints out JSON information
    about the DNS change which was created as a result, with records in the
    same form as returned by `dns get`.

    Note: This command only handles regular DNS records, and not aliases or
    other AWS-specific stuff.

    <binding>
      [<name>:]<type>=<value> -- Create a record of the given type with the
        given value. With `<name>`, uses that as the name-and-subdomain; without
        it, then the `--name` option provides the name to bind. It is valid to
        repeat the same name and type multiple times; this indicates a
        multi-valued record.

    --domain=<name-or-id>
      Main domain to operate on. Can be either a domain name per se or a Zone ID.
      Required.
    --name=<name>
      Name and subdomain (but not main domain name) to operate on, for <binding>s
      that don\'t specify one. Use `.` to indicate an apex record. Required if
      any <binding>s do not include a name.
    --merge
      Merges records, keeping old values for a given name/type, and just adding
      to them. Without this option, existing records are replaced (and
      nonexistent records are created).
    --ttl
      TTL to use for all added records. Required.
    --[no-]wait
      Wait for the DNS records to be synchronized? `--wait` is the default.

    ${name} [--help | -h]

    Displays this message.
'

# Want help?
opt-action --call='{ usage; exit }' help/h

# TODO: Handle usual output arguments. It's hard here because we also take
# other rest args.

# Domain to operate on.
opt-value --required --var=domain --filter='/^[-./a-zA-Z0-9]+$/' domain

# Name to operate on by default.
opt-value --var=name --filter='/^[-_.a-z0-9]+$/' name

# Merge instead of replace?
opt-toggle --var=doMerge merge

# TTL for records.
opt-value --required --var=ttl --filter='/^[0-9]+/' ttl

# Wait for DNS records to be in synch?
opt-toggle --var=waitForSync --init=1 wait

# List of bindings, as parallel arrays of name, type, and value.
bindNames=()
bindTypes=()
bindValues=()

rest-arg --call=parse-bindings bindings
function parse-bindings {
    local arg
    local error=0

    while (( $# > 0 )); do
        arg="$1"
        shift

        if ! [[ ${arg} =~ ^([-_.a-zA-Z0-9]+:)?([a-z]+)=(.+)$ ]]; then
            error-msg 'Could not parse binding:' "${arg}"
            error=1
            continue
        fi

        bindNames+=("${BASH_REMATCH[1]%:}") # `%:` to remove the trailing colon.
        bindTypes+=("${BASH_REMATCH[2]}")
        bindValues+=("${BASH_REMATCH[3]}")
    done

    return "${error}"
}

process-args "$@" || usage --short


#
# Helper functions
#

# Retrieves all existing records associated with any name/type mentioned in the
# <bindings>. This is used when merging records. Note that the result uses
# names without the final domain and lowercase types.
function get-existing-records {
    local domain="$1"
    local zoneId="$2"
    local treeJson="$3"

    local result
    result="$(lib aws-json route53 list-resource-record-sets --global \
        zoneId="${zoneId}" '{ HostedZoneId: $zoneId }' \
        :: \
        domain="${domain}" \
        tree:json="${treeJson}" '
        def simpleName($name):
            $name
            | rtrimstr("\($domain).")
            | if . == "" then "." else . end
        ;

        def doExtract:
            ($tree | keys) as $names
            |
            map(
                simpleName(.Name) as $name
                |
                (.Type | ascii_downcase) as $type
                |
                select($tree[$name][$type] != null)
                |
                {
                    name:   $name,
                    type:   $type,
                    values: (.ResourceRecords | map(.Value))
                }
            )
            |
            # This forms the tree.
            reduce .[] as $item (null; .[$item.name][$item.type] += $item.values)
        ;

        if .IsTruncated == true then
            "truncated"
        else
            .ResourceRecordSets | doExtract
        end
        '
    )" \
    || exit "$?"

    if [[ ${existingJson} == '"truncated"' ]]; then
        error-msg 'Cannot handle truncated response from Route53. Sorry!'
        return 1
    fi

    echo "${result}"
}

# Makes a tree out of the parallel arrays that define the bindings. The result
# is along the lines of the following:
#
# ```
# {
#   "florp": {
#     "txt": [
#       "\"one\"",
#       "\"two\""
#     ]
#   },
#   ".": {
#     "a": [
#       "10.1.2.3"
#     ],
#     "aaaa": [
#       "10::10"
#     ]
#   }
# }
# ```
function make-binding-tree {
    local namesJson="$1"
    local typesJson="$2"
    local valuesJson="$3"

    jval \
        names:json="${namesJson}" \
        types:json="${typesJson}" \
        values:json="${valuesJson}" '

        [$names, $types, $values]
        |
        transpose
        |
        map({
            name:  .[0],
            type:  .[1],
            value: .[2]
        })
        |
        # This produces an object which maps names to an object that maps types to
        # arrays of values.
        reduce .[] as $item (null; .[$item.name][$item.type] += [$item.value])
    '
}

# Merges two trees (per above) together, producing value arrays that contain the
# union of values of the two at each corresponding element.
function merge-trees {
    local tree1="$1"
    local tree2="$2"

    jval \
        tree1:json="${tree1}" \
        tree2:json="${tree2}" '

        def merge($v1; $v2):

            def mergeArrays($v1; $v2):
                ($v1 + $v2) | unique
            ;

            def mergeObjects($v1; $v2):
                reduce ($v2 | to_entries[]) as { key: $key, value: $sub2 } (
                    $v1;
                    . as $soFar
                    |
                    .[$key] as $sub1
                    |
                    merge($sub1; $sub2)
                    |
                    $soFar + { ($key): . }
                )
            ;

            ($v1 | type) as $type1 # Assumes same type for `$v2`.
            |
            ($v2 | type) as $type2
            |
            if $v1 == null then
                $v2
            elif $v2 == null then
                $v1
            elif $type1 != $type2 then
                halt_error("Type mismatch at (\($v1), \($v2)).")
            elif $type1 == "array" then
                mergeArrays($v1; $v2)
            elif $type1 == "object" then
                mergeObjects($v1; $v2)
            else
                halt_error("Cannot merge type \($type1) at  (\($v1), \($v2)).")
            end
        ;

        merge($tree1; $tree2)
    '
}

# Converts a tree of bindings to a list of records in the form used by this
# project.
function record-list-from-tree {
    local ttl="$1"
    local treeJson="$2"

    info-msg '###### ORIG'
    info-msg --exec jget "${treeJson}"
    info-msg '#######'

    jval \
        tree:json="${treeJson}" \
        ttl:json="${ttl}" '

        def expandTypeMap($name; $typeMap):
            $typeMap | to_entries[]
            |
            . as { key: $type, value: $values }
            |
            {
                name:   $name,
                type:   $type,
                ttl:    $ttl,
                values: $values
            }
        ;

        [
            $tree | to_entries[]
            |
            . as { key: $name, value: $typeMap }
            |
            expandTypeMap($name; $typeMap)
        ]
        '
}

# Converts a record list in the form used in this project to the change list
# form used by Route53.
function route53-change-list {
    local domain="$1"
    local recordsJson="$2"

    info-msg '###### RECORDS'
    info-msg --exec jget "${recordsJson}"
    info-msg '#######'

    jval \
        domain="${domain}" \
        records:json="${recordsJson}" '

        def makeName($name):
            if $name == "." then "\($domain)." else "\($name).\($domain)." end
        ;

        $records
        |
        map({
            Action: "UPSERT",
            ResourceRecordSet: {
                Name: makeName(.name),
                Type: .type | ascii_upcase,
                TTL:  .ttl,
                ResourceRecords: [.values[] | { Value: . }]
            }
        })
        '
}


#
# Main script
#

# Fill in the name on any bindings that don't have one.

for n in "${!bindNames[@]}"; do
    if [[ ${bindNames[n]} == '' ]]; then
        if [[ ${name} == '' ]]; then
            error-msg 'Must supply `--name` when using nameless bindings.'
            usage --short
            exit 1
        fi
        bindNames[n]="${name}"
    fi
done

for n in "${!bindNames[@]}"; do
    info-msg "### >>${bindNames[n]}<< >>${bindTypes[n]}<< >>${bindValues[n]}<<"
done

# Look up the domain, and extract the name and ID. (We need to get the domain
# name, because the original `--domain` might have been specified as an ID.)
zoneInfo="$(lib dns find-zone --domain="${domain}")" || exit "$?"
zoneId="$(jget --output=raw "${zoneInfo}" '.id')"
domain="$(jget --output=raw "${zoneInfo}" '.name')"

# Convert bindings into a tree form.
treeJson="$(make-binding-tree \
    "$(jarray --input=strings "${bindNames[@]}")" \
    "$(jarray --input=strings "${bindTypes[@]}")" \
    "$(jarray --input=strings "${bindValues[@]}")"
)" \
|| exit "$?"

if (( doMerge )); then
    existingJson="$(get-existing-records "${domain}" "${zoneId}" "${treeJson}")" \
    || exit "$?"
    info-msg '####### EXISTING'
    jget "${existingJson}"
    treeJson="$(merge-trees "${existingJson}" "${treeJson}")" \
    || exit "$?"
    info-msg '####### MERGED'
fi

# Form it into a list of records.
recordsJson="$(record-list-from-tree "${ttl}" "${treeJson}")" \
|| exit "$?"

# And further form it into the Route53 change list form.
changesJson="$(route53-change-list "${domain}" "${recordsJson}")" \
|| exit "$?"

info-msg '########## CHANGES'
jget "${changesJson}"
info-msg '##########'

# TODO: Retrieve any salient existing records (e.g. to determine add vs.
# upsert, and provide the baseline for merges).

# TODO: Make final Route53 call.

error-msg TODO
exit 1
