#!/bin/bash
#
# Copyright 2022-2023 the Milk-prod Authors (Dan Bornstein et alia).
# This project is PROPRIETARY and UNLICENSED.

. "$(dirname "$(readlink -f "$0")")/_init.sh" || exit "$?"
. "$(this-cmd-dir)/dns-help.sh"


#
# Argument parsing
#

define-usage $'
    ${name} [<opt> ...] <binding> ...

    Adds, merges, or replaces one or more DNS records. Prints out JSON information
    about the DNS change which was created as a result, with records in the
    same form as returned by `dns get`.

    Note: This command only handles regular DNS records, and not aliases or
    other AWS-specific stuff.

    <binding>
      [<name>:]<type>=<value> -- Create a record of the given type with the
        given value. With `<name>`, uses that as the name-and-subdomain; without
        it, then the `--name` option provides the name to bind. It is valid to
        repeat the same name and type multiple times; this indicates a
        multi-valued record.

    --domain=<name-or-id>
      Main domain to operate on. Can be either a domain name per se or a Zone ID.
      Required.
    --name=<name>
      Name and subdomain (but not main domain name) to operate on, for <binding>s
      that don\'t specify one. Use `.` to indicate an apex record. Required if
      any <binding>s do not include a name.
    --merge
      Merges records, keeping old values for a given name/type, and just adding
      to them. Without this option, existing records are replaced (and
      nonexistent records are created).
    --ttl
      TTL to use for all added records. Required.
    --[no-]wait
      Wait for the DNS records to be synchronized? `--wait` is the default.

    ${name} [--help | -h]

    Displays this message.
'

# Want help?
opt-action --call='{ usage; exit }' help/h

# TODO: Handle usual output arguments. It's hard here because we also take
# other rest args.

# Domain to operate on.
opt-value --required --var=domain --filter='/^[-./a-zA-Z0-9]+$/' domain

# Name to operate on by default.
opt-value --var=name --filter='/^[-_.a-z0-9]+$/' name

# Merge instead of replace?
opt-toggle --var=doMerge merge

# TTL for records.
opt-value --required --var=ttl --filter='/^[0-9]+/' ttl

# Wait for DNS records to be in synch?
opt-toggle --var=waitForSync --init=1 wait

# List of bindings, as parallel arrays of name, type, and value.
bindNames=()
bindTypes=()
bindValues=()

rest-arg --call=parse-bindings bindings
function parse-bindings {
    local arg
    local error=0

    while (( $# > 0 )); do
        arg="$1"
        shift

        if ! [[ ${arg} =~ ^([-_.a-zA-Z0-9]+:)?([a-z]+)=(.+)$ ]]; then
            error-msg 'Could not parse binding:' "${arg}"
            error=1
            continue
        fi

        bindNames+=("${BASH_REMATCH[1]%:}") # `%:` to remove the trailing colon.
        bindTypes+=("${BASH_REMATCH[2]}")
        bindValues+=("${BASH_REMATCH[3]}")
    done

    return "${error}"
}

process-args "$@" || usage --short


#
# Helper functions
#

# Retrieves all existing records associated with any name/type mentioned in the
# <bindings>. This is used when merging records. The result is converted into
# this project's standard form for a change list (e.g. names without the final
# domain).
function get-existing-records {
    local domain="$1"
    local zoneId="$2"
    local newRecords="$3"

    local result
    result="$(lib aws-json route53 list-resource-record-sets --global \
        zoneId="${zoneId}" '{ HostedZoneId: $zoneId }' \
        :: \
        domain="${domain}" \
        newRecords:json="${newRecords}" '
        def simpleName($name):
            $name
            | rtrimstr("\($domain).")
            | if . == "" then "." else rtrimstr(".") end
        ;

        def doExtract:
            ($newRecords | map({ name, type }) | sort) as $salient
            |
            map(
                simpleName(.Name) as $name
                |
                (.Type | ascii_downcase) as $type
                |
                {
                    name:   $name,
                    type:   $type,
                    ttl:    .TTL,
                    values: (.ResourceRecords | map(.Value))
                }
                |
                select(
                      { name, type } as $key
                    | ($salient | bsearch($key)) >= 0
                )
            )
        ;

        if .IsTruncated == true then
            "truncated"
        else
            .ResourceRecordSets | doExtract
        end
        '
    )" \
    || exit "$?"

    if [[ ${existingJson} == '"truncated"' ]]; then
        error-msg 'Cannot handle truncated response from Route53. Sorry!'
        return 1
    fi

    echo "${result}"
}

# Retrieves all existing records associated with any name/type mentioned in the
# <bindings>. This is used when merging records. Note that the result uses
# names without the final domain and lowercase types.
function get-existing-records-tree {
    local domain="$1"
    local zoneId="$2"
    local treeJson="$3"

    local result
    result="$(lib aws-json route53 list-resource-record-sets --global \
        zoneId="${zoneId}" '{ HostedZoneId: $zoneId }' \
        :: \
        domain="${domain}" \
        tree:json="${treeJson}" '
        def simpleName($name):
            $name
            | rtrimstr("\($domain).")
            | if . == "" then "." else . end
        ;

        def doExtract:
            ($tree | keys) as $names
            |
            map(
                simpleName(.Name) as $name
                |
                (.Type | ascii_downcase) as $type
                |
                select($tree[$name][$type] != null)
                |
                {
                    name:   $name,
                    type:   $type,
                    values: (.ResourceRecords | map(.Value))
                }
            )
            |
            # This forms the tree.
            reduce .[] as $item (null; .[$item.name][$item.type] += $item.values)
        ;

        if .IsTruncated == true then
            "truncated"
        else
            .ResourceRecordSets | doExtract
        end
        '
    )" \
    || exit "$?"

    if [[ ${existingJson} == '"truncated"' ]]; then
        error-msg 'Cannot handle truncated response from Route53. Sorry!'
        return 1
    fi

    echo "${result}"
}

# Makes a tree out of the parallel arrays that define the bindings. The result
# is along the lines of the following:
#
# ```
# {
#   "florp": {
#     "txt": [
#       "\"one\"",
#       "\"two\""
#     ]
#   },
#   ".": {
#     "a": [
#       "10.1.2.3"
#     ],
#     "aaaa": [
#       "10::10"
#     ]
#   }
# }
# ```
function make-binding-tree {
    local namesJson="$1"
    local typesJson="$2"
    local valuesJson="$3"

    jval \
        names:json="${namesJson}" \
        types:json="${typesJson}" \
        values:json="${valuesJson}" '

        [$names, $types, $values]
        |
        transpose
        |
        map({
            name:  .[0],
            type:  .[1],
            value: .[2]
        })
        |
        # This produces an object which maps names to an object that maps types to
        # arrays of values.
        reduce .[] as $item (null; .[$item.name][$item.type] += [$item.value])
    '
}

# Merges two record lists (in the form used by this project) together, producing
# a result with value arrays that contain the union of values of the two inputs
# at each corresponding element. In case of overlap/mismatch (e.g. two different
# TTLs for a particular record), the second list overrides the first.
function merge-record-lists {
    local list1="$1"
    local list2="$2"

    jval \
        list1:json="${list1}" \
        list2:json="${list2}" '
        [$list1[], $list2[]]
        |
        group_by({ name, type })
        |
        map({
            name:   .[0].name,
            type:   .[0].type,
            ttl:    .[-1].ttl,
            values: (map(.values) | add | sort)
        })
        '
}

# Merges two trees (per above) together, producing value arrays that contain the
# union of values of the two at each corresponding element.
function merge-trees {
    local tree1="$1"
    local tree2="$2"

    jval \
        tree1:json="${tree1}" \
        tree2:json="${tree2}" '

        def merge($v1; $v2):

            def mergeArrays($v1; $v2):
                ($v1 + $v2) | unique
            ;

            def mergeObjects($v1; $v2):
                reduce ($v2 | to_entries[]) as { key: $key, value: $sub2 } (
                    $v1;
                    . as $soFar
                    |
                    .[$key] as $sub1
                    |
                    merge($sub1; $sub2)
                    |
                    $soFar + { ($key): . }
                )
            ;

            ($v1 | type) as $type1 # Assumes same type for `$v2`.
            |
            ($v2 | type) as $type2
            |
            if $v1 == null then
                $v2
            elif $v2 == null then
                $v1
            elif $type1 != $type2 then
                halt_error("Type mismatch at (\($v1), \($v2)).")
            elif $type1 == "array" then
                mergeArrays($v1; $v2)
            elif $type1 == "object" then
                mergeObjects($v1; $v2)
            else
                halt_error("Cannot merge type \($type1) at  (\($v1), \($v2)).")
            end
        ;

        merge($tree1; $tree2)
    '
}

# Converts the parallel arrays that are formed from the arguments to this
# command, along with a TTL value, into a list of records in the form used by
# this project.
function record-list-from-arrays {
    local ttl="$1"
    local namesJson="$2"
    local typesJson="$3"
    local valuesJson="$4"

    jval \
        ttl:json="${ttl}" \
        names:json="${namesJson}" \
        types:json="${typesJson}" \
        values:json="${valuesJson}" '

        [$names, $types, $values]
        |
        transpose
        |
        map({
            name:  .[0],
            type:  .[1],
            value: .[2]
        })
        |
        group_by([.name, .type])
        |
        map({
            name:   .[0].name,
            type:   .[0].type,
            ttl:    $ttl,
            values: map(.value)
        })
    '
}

# Converts a tree of bindings to a list of records in the form used by this
# project.
function record-list-from-tree {
    local ttl="$1"
    local treeJson="$2"

    jval \
        tree:json="${treeJson}" \
        ttl:json="${ttl}" '

        def expandTypeMap($name; $typeMap):
            $typeMap | to_entries[]
            |
            . as { key: $type, value: $values }
            |
            {
                name:   $name,
                type:   $type,
                ttl:    $ttl,
                values: $values
            }
        ;

        [
            $tree | to_entries[]
            |
            . as { key: $name, value: $typeMap }
            |
            expandTypeMap($name; $typeMap)
        ]
        '
}

# Converts a record list in the form used in this project to the change list
# form used by Route53.
function route53-change-list {
    local domain="$1"
    local recordsJson="$2"

    jval \
        domain="${domain}" \
        records:json="${recordsJson}" '

        def makeName($name):
            if $name == "." then "\($domain)." else "\($name).\($domain)." end
        ;

        $records
        |
        map({
            Action: "UPSERT",
            ResourceRecordSet: {
                Name: makeName(.name),
                Type: .type | ascii_upcase,
                TTL:  .ttl,
                ResourceRecords: [.values[] | { Value: . }]
            }
        })
        '
}


#
# Main script
#

progress-msg --enable

# Fill in the name on any bindings that don't have one.

for n in "${!bindNames[@]}"; do
    if [[ ${bindNames[n]} == '' ]]; then
        if [[ ${name} == '' ]]; then
            error-msg 'Must supply `--name` when using nameless bindings.'
            usage --short
            exit 1
        fi
        bindNames[n]="${name}"
    fi
done

# Convert the binding arrays to an array of records.
newRecords="$(record-list-from-arrays \
    "${ttl}" \
    "$(jarray --input=strings "${bindNames[@]}")" \
    "$(jarray --input=strings "${bindTypes[@]}")" \
    "$(jarray --input=strings "${bindValues[@]}")"
)" \
|| exit "$?"

info-msg '####### NEW'
jget "${newRecords}"
info-msg '#######'

# Look up the domain, and extract the name and ID. (We need to get the domain
# name, because the original `--domain` might have been specified as an ID.)
zoneInfo="$(lib dns find-zone --domain="${domain}")" || exit "$?"
zoneId="$(jget --output=raw "${zoneInfo}" '.id')"
domain="$(jget --output=raw "${zoneInfo}" '.name')"

# Merge on top of existing records, if so requested.
oldRecords='[]'
if (( doMerge )); then
    info-msg '####### GETTING'
    oldRecords="$(get-existing-records "${domain}" "${zoneId}" "${newRecords}")" \
    || exit "$?"
    info-msg '####### EXISTING'
    jget "${oldRecords}"
    info-msg '####### MERGING'
    newRecords="$(merge-record-lists "${oldRecords}" "${newRecords}")"
    info-msg '####### NEW NEW'
    jget "${newRecords}"
    info-msg '#######'
fi

# Form the records into the Route53 change list form.
changesJson="$(route53-change-list "${domain}" "${newRecords}")" \
|| exit "$?"

changeId="$(lib aws-json route53 change-resource-record-sets --global \
    changes:json="${changesJson}" \
    zoneId="${zoneId}" '{
        HostedZoneId: $zoneId,
        ChangeBatch: {
            Comment: "Via `dns add`",
            Changes: $changes
        }
    }' \
    :: --output=raw '.ChangeInfo.Id'
)" \
|| exit "$?"

if (( waitForSync )); then
    wait-for-dns-sync "${changeId}" \
    || exit "$?"
fi

resultArray="$(jval \
    changeId="${changeId}" \
    domain="${domain}" \
    newRecords:json="${newRecords}" \
    oldRecords:json="${oldRecords}" \
    zoneId="${zoneId}" '[{
        changeId:   $changeId,
        domain:     $domain,
        zoneId:     $zoneId,
        oldRecords: $oldRecords,
        newRecords: $newRecords
    }]'
)"

# TODO: Output postprocessing.
jget "${resultArray}"
