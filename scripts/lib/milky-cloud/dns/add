#!/bin/bash
#
# Copyright 2022-2023 the Milk-prod Authors (Dan Bornstein et alia).
# This project is PROPRIETARY and UNLICENSED.

. "$(dirname "$(readlink -f "$0")")/_init.sh" || exit "$?"


#
# Argument parsing
#

define-usage $'
    ${name} [<opt> ...] <binding> ...

    Adds, merges, or replaces one or more DNS records. Prints out JSON information
    about the DNS change which was created as a result.

    Note: This command only handles regular DNS records, and not aliases or
    other AWS-specific stuff.

    <binding>
      [<name>:]<type>=<value> -- Create a record of the given type with the
        given value. With `<name>`, uses that as the name-and-subdomain; without
        it, then the `--name` option provides the name to bind. It is valid to
        repeat the same name and type multiple times; this indicates a
        multi-valued record.

    --domain=<name-or-id>
      Main domain to operate on. Can be either a domain name per se or a Zone ID.
      Required.
    --name=<name>
      Name and subdomain (but not main domain name) to operate on, for <binding>s
      that don\'t specify one. Use `.` to indicate an apex record. Required if
      any <binding>s do not include a name.
    --merge
      Merges records, keeping old values for a given name/type, and just adding
      to them. Without this option, existing records are replaced (and
      nonexistent records are created).
    --[no-]wait
      Wait for the DNS records to be synchronized? `--wait` is the default.

    ${name} [--help | -h]

    Displays this message.
'

# Want help?
opt-action --call='{ usage; exit }' help/h

# TODO: Handle usual output arguments. It's hard here because we also take
# other rest args.

# Domain to operate on.
opt-value --required --var=domain --filter='/^[-./a-zA-Z0-9]+$/' domain

# Name to operate on by default.
opt-value --var=name --filter='/^[-_.a-z0-9]+$/' name

# Merge instead of replace?
opt-toggle --var=doMerge merge

# List of bindings, as parallel arrays of name, type, and value.
bindNames=()
bindTypes=()
bindValues=()

rest-arg --call=parse-bindings bindings
function parse-bindings {
    local arg
    local error=0

    while (( $# > 0 )); do
        arg="$1"
        shift

        if ! [[ ${arg} =~ ^([-_.a-zA-Z0-9]+:)?([a-z]+)=(.+)$ ]]; then
            error-msg 'Could not parse binding:' "${arg}"
            error=1
            continue
        fi

        bindNames+=("${BASH_REMATCH[1]%:}") # `%:` to remove the trailing colon.
        bindTypes+=("${BASH_REMATCH[2]}")
        bindValues+=("${BASH_REMATCH[3]}")
    done

    return "${error}"
}

process-args "$@" || usage --short


#
# Helper functions
#

# Retrieves existing records associated with any name/type mentioned in the
# <bindings>. This is needed when merging.
function get-existing-records {
    : TODO
}

#
# Main script
#

# Fill in the name on any bindings that don't have one.

for n in "${!bindNames[@]}"; do
    if [[ ${bindNames[n]} == '' ]]; then
        if [[ ${name} == '' ]]; then
            error-msg 'Must supply `--name` when using nameless bindings.'
            usage --short
            exit 1
        fi
        bindNames[n]="${name}"
    fi
done

for n in "${!bindNames[@]}"; do
    info-msg "### >>${bindNames[n]}<< >>${bindTypes[n]}<< >>${bindValues[n]}<<"
done

# Look up the domain, and extract the name and ID. (We need to get the domain
# name, because the original `--domain` might have been specified as an ID.)

zoneInfo="$(lib dns find-zone --domain="${domain}")" \
|| exit "$?"

# Extract the domain name and ID. (We need to get the domain name, because the
# original `--domain` might have been specified as an ID.)
zoneId="$(jget --output=raw "${zoneInfo}" '.id')"
domain="$(jget --output=raw "${zoneInfo}" '.name')"

# Produce an object that maps names to an object that maps types to arrays of
# values. The names are expanded into their canonical form for use with AWS, and
# likewise types are upcased.

treeJson="$(jval \
    domain="${domain}" \
    names:json="$(jarray --input=strings "${bindNames[@]}")" \
    types:json="$(jarray --input=strings "${bindTypes[@]}")" \
    values:json="$(jarray --input=strings "${bindValues[@]}")" '
    def makeName($name):
        if $name == "." then "\($domain)." else "\($name).\($domain)." end;
    [$names, $types, $values]
    |
    transpose
    |
    map({
        name:  makeName(.[0]),
        type:  (.[1] | ascii_upcase),
        value: .[2]
    })
    |
    # This produces an object which maps names to an object that maps types to
    # arrays of values.
    reduce .[] as $item (null; .[$item.name][$item.type] += [$item.value])
    '
)" \
|| exit "$?"

# Get any records associated with the names being manipulated. Produces an
# object in the same form as `treeJson`.

existingJson="$(lib aws-json route53 list-resource-record-sets --global \
    zoneId="${zoneId}" '{ HostedZoneId: $zoneId }' \
    :: \
    tree:json="${treeJson}" '
    def doExtract:
        ($tree | keys) as $names
        |
        map(
            .Name as $name
            |
            .Type as $type
            |
            select($tree[$name][$type] != null)
            |
            {
                name:   .Name,
                type:   .Type,
                values: (.ResourceRecords | map(.Value))
            }
        )
        |
        reduce .[] as $item (null; .[$item.name][$item.type] += $item.values)
    ;
    if .IsTruncated == true then
        "truncated"
    else
        .ResourceRecordSets | doExtract
    end
    '
)" \
|| exit "$?"

if [[ ${existingJson} == '"truncated"' ]]; then
    error-msg 'Cannot handle truncated response from Route53. Sorry!'
    exit 1
fi

info-msg '########## TREE'
jget "${treeJson}"
info-msg '########## EXISTING'
jget "${existingJson}"
info-msg '##########'

# TODO: Retrieve any salient existing records (e.g. to determine add vs.
# upsert, and provide the baseline for merges).

# TODO: Make final Route53 call.

error-msg TODO
exit 1
