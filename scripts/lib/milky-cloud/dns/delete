#!/bin/bash
#
# Copyright 2022-2023 the Milk-prod Authors (Dan Bornstein et alia).
# This project is PROPRIETARY and UNLICENSED.

. "$(dirname "$(readlink -f "$0")")/_init.sh" || exit "$?"
. "$(this-cmd-dir)/dns-help.sh"


#
# Argument parsing
#

define-usage $'
    ${name} [<opt> ...] [:: [<out-opt> ...] [<jval-expr> ...]]

    Deletes all DNS records that match the indicated query, which is performed
    using the same options as `dns get` (see which). Output is a single JSON
    object binding information about the DNS change request.

    --domain=<name-or-id>
      Main domain to match. Can be either a domain name per se or a Zone ID.
      Required.
    --name=<name>
      Name and subdomain (but not main domain name) to match. Use `.` to indicate
      an apex record. Required.
    --not-found-ok
      Do not report an error if fewer records were found than implied by the
      given number of `--type`s.
    --output=<style> :: array json none
      What to output, as with `dns get`.
    --type=<list>
      A space-separated list of one or more record types (in lower case).
      Required.
    --value=<value>
      Specific value to delete. If specified, only this value will be deleted,
      and other values in matched records are left alone.
    --[no-]wait
      Wait for the DNS records to be synchronized? `--wait` is the default.

    ${name} [--help | -h]

    Displays this message.
'

# Want help?
opt-action --call='{ usage; exit }' help/h

# Handles JSON `--output` and post-processing arguments.
usual-json-output-args

# Options passed to `dns get`
getOpts=()
findValue=''
opt-value --call='{ getOpts+=(--domain="$1") }' domain
opt-value --call='{ getOpts+=(--name="$1") }' name
opt-toggle --call='{ getOpts+=(--not-found-ok="$1") }' not-found-ok
opt-value --call='{ getOpts+=(--type="$1") }' type
opt-value --call='{ getOpts+=(--value="$1"); findValue="$1" }' value

# Wait for DNS records to be in synch?
opt-toggle --var=waitForSync --init=1 wait

process-args "$@" || usage --short

check-json-output-args \
|| exit "$?"


#
# Main script
#

progress-msg --enable

# Get the existing records.
recordsArray="$(lib dns get "${getOpts[@]}" --output=array)" \
|| exit "$?"

if [[ ${recordsArray} == '[]' ]]; then
    info-msg 'Nothing to delete; no matching records.'
    exit
fi

domain="$(jget --output=raw "${recordsArray}" '.[0].domain')"
zoneId="$(jget --output=raw "${recordsArray}" '.[0].zoneId')"

# Filter the records array, transforming it into a list of deletes and upserts.
changesArray="$(
    jget "${recordsArray}" \
        domain="${domain}" \
        findValue="${findValue}" '
        def makeResult($action; $record):
            $record
            |
            {
                Action: $action,
                ResourceRecordSet: {
                    Name: "\(.name).\($domain).",
                    Type: (.type | ascii_upcase),
                    TTL:  .ttl,
                    ResourceRecords: [.values[] | { Value: . }]
                }
            }
        ;
        map(
            (if $findValue == "" then
                []
            else
                (.values | map(select(. != $findValue)))
            end)
            as $newValues
            |
            if $newValues == [] then
                makeResult("DELETE"; .)
            else
                makeResult("UPSERT"; .values = $newValues)
            end
        )
')"

changeId="$(lib aws-json route53 change-resource-record-sets --global \
    changes:json="${changesArray}" \
    zoneId="${zoneId}" '{
        HostedZoneId: $zoneId,
        ChangeBatch: {
            Comment: "Via `dns delete`",
            Changes: $changes
        }
    }' \
    :: --output=raw '.ChangeInfo.Id'
)" \
|| exit "$?"

if (( waitForSync )); then
    wait-for-dns-sync "${changeId}" \
    || exit "$?"
fi

resultArray="$(jval \
    changeId="${changeId}" \
    domain="${domain}" \
    records:json="${recordsArray}" \
    zoneId="${zoneId}" '[{
        changeId: $changeId,
        domain: $domain,
        zoneId: $zoneId,
        originalRecords: $records
    }]'
)"

json-postproc-output "${resultArray}"
