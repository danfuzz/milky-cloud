#!/bin/bash
#
# Copyright 2022-2023 the Milk-prod Authors (Dan Bornstein et alia).
# This project is PROPRIETARY and UNLICENSED.

. "$(dirname "$(readlink -f "$0")")/_init.sh" || exit "$?"


#
# Argument parsing
#

define-usage $'
    ${name} [<opt> ...] [:: [<out-opt> ...] [<jval-expr> ...]]

    Deletes all DNS records that match the indicated query, which is performed
    using the same options as `dns get` (see which). Output is a single JSON
    object binding information about the DNS change request.

    --domain=<name-or-id>
      Main domain to match. Can be either a domain name per se or a Zone ID.
      Required.
    --name=<name>
      Name and subdomain (but not main domain name) to match. Use `.` to indicate
      an apex record. Required.
    --not-found-ok
      Do not report an error if fewer records were found than implied by the
      given number of `--type`s.
    --output=<style> :: array json none
      What to output, as with `dns get`.
    --type=<list>
      A space-separated list of one or more record types (in lower case).
      Required.
    --value=<value>
      Specific value to delete. If specified, only this value will be deleted,
      and other values in matched records are left alone.

    ${name} [--help | -h]

    Displays this message.
'

# Want help?
opt-action --call='{ usage; exit }' help/h

# Handles JSON `--output` and post-processing arguments.
usual-json-output-args

# Options passed to `dns get`
getOpts=()
findValue=''
opt-value --call='{ getOpts+=(--domain="$1") }' domain
opt-value --call='{ getOpts+=(--name="$1") }' name
opt-toggle --call='{ getOpts+=(--not-found-ok="$1") }' not-found-ok
opt-value --call='{ getOpts+=(--type="$1") }' type
opt-value --call='{ getOpts+=(--value="$1"); findValue="$1" }' value

process-args "$@" || usage --short

check-json-output-args \
|| exit "$?"


#
# Main script
#

# Get the existing records.
recordsArray="$(lib dns get "${getOpts[@]}" --output=array)" \
|| exit "$?"

if [[ ${recordsArray} == '[]' ]]; then
    info-msg 'Nothing to delete; no matching records.'
    exit
fi

domain="$(jget --output=raw "${recordsArray}" '.[0].domain')"
zoneId="$(jget --output=raw "${recordsArray}" '.[0].zoneId')"

# Filter the records array, transforming it into a list of deletes and upserts.
changesArray="$(
    jget "${recordsArray}" \
        findValue="${findValue}" '
        def makeResult($action; $record):
            $record
            |
            {
                Action: $action,
                ResourceRecordSet: {
                    Name: .name,
                    Type: (.type | ascii_upcase),
                    TTL:  .ttl,
                    ResourceRecords: [.values | map({ Value: . })]
                }
            }
        ;
        map(
            (if $findValue == "" then
                []
            else
                (.values | map(select(. != $findValue)))
            end)
            as $newValues
            |
            if $newValues == [] then
                makeResult("DELETE"; .)
            else
                makeResult("UPSERT"; .values = $newValues)
            end
        )
')"

# TODO: Pass the changes array into the AWS call.

jget "${changesArray}"
error-msg TODO
exit 1

##################################
# STUFF FROM `dns get`

# Canonicalize the `name` by ensuring it does not end with a `.`
if [[ ${name} =~ ^(.*)[.]$ ]]; then
    name="${BASH_REMATCH[1]}"
fi

# Canonicalize the `domain` by ensuring it does not end with a `.`
if [[ ${domain} =~ ^(.*)[.]$ ]]; then
    domain="${BASH_REMATCH[1]}"
fi

# Avoid weirdness: Reject `name` if it ends with the domain name.
if [[ ${name} =~ ".${domain}" ]]; then
    error-msg 'Do not append the `--domain` to the `--name`.'
    exit 1
fi

# Convert `types` to a sorted JSON array of uppercase names.
types="$(
    jval types="${types}" '
        $types
        | split(" "; "g")
        | map(select(. != "") | ascii_upcase)
        | sort'
)" \
|| exit "$?"

if [[ ${types} == '[]' ]]; then
    error-msg 'No types listed!'
    usage --short
    exit 1
fi

zoneInfo="$(lib dns find-zone --domain="${domain}")" \
|| exit "$?"

# Extract the domain name and ID. (We need to get the domain name, because the
# original `--domain` might have been specified as an ID.)
zoneId="$(jget --output=raw "${zoneInfo}" '.id')"
domain="$(jget --output=raw "${zoneInfo}" '.name')"

fullName=
if [[ ${name} == '' ]]; then
    fullName="${domain}."
else
    fullName="${name}.${domain}."
fi

result="$(lib aws-json route53 list-resource-record-sets --global \
    fullName="${fullName}" \
    types:json="${types}" \
    zoneId="${zoneId}" '
    {
        HostedZoneId:    $zoneId,
        StartRecordName: $fullName,
        StartRecordType: $types[0]
    }
    +
    if ($types | length) == 1 then
        { MaxItems: "1" }
    else
        .
    end' \
    :: \
    fullName="${fullName}" \
    notFoundOk:json="${notFoundOk}" \
    types:json="${types}" '
    .ResourceRecordSets
    |
    map(select(
        (.Name == $fullName)
        and
        ((.Type as $type | $types | bsearch($type)) >= 0)
    ))
    |
    map({
        name:   .Name,
        type:   .Type,
        ttl:    .TTL,
        values: (.ResourceRecords | map(.Value))
    })
    |
    if ($notFoundOk == 1) or (length == ($types | length)) then
        .
    else
        { count: length }
    end
    '
)" \
|| exit "$?"

if [[ ${result} =~ ^'{' ]]; then
    len="$(jget "${result}" '.count')"
    if (( len == 0 )); then
        error-msg 'No matching records found.'
    else
        error-msg "Insufficient matching records found. (Found ${len}.)"
    fi
    exit 1
fi

json-postproc-output "${result}"
