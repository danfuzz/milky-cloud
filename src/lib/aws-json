#!/bin/bash
#
# Copyright 2022 Dan Bornstein.
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

# Set `progName` to the program name, `progDir` to its directory, and `baseDir`
# to `progDir`'s directory. Follows symlinks.
function init-prog {
    local newp p="$0"

    while newp="$(readlink "$p")"; do
        [[ ${newp} =~ ^/ ]] && p="${newp}" || p="$(dirname "$p")/${newp}"
    done

    progName="${p##*/}"
    progDir="$(cd "$(dirname "$p")"; /bin/pwd -P)"
    baseDir="$(cd "${progDir}/.."; /bin/pwd -P)"
}
init-prog

# Set up for library-internal usage.
. "${progDir}/init" --lib


#
# Helper functions
#

# Constructs a JSON value to represent all the pieces of a command, based on the
# globals set up by the main script.
function make-command-parts-json {
    local dashArgsJson="$(jarray --strings -- "${dashArgs[@]}")"

    jval \
        command="${command}" \
        subcommand="${subcommand}" \
        jsonArg:json="${jsonArg}" \
        dashArgs:json="${dashArgsJson}" \
        '{
            command:    $command,
            subcommand: $subcommand,
            jsonArg:    $jsonArg,
            dashArgs:   $dashArgs
        }'
}


#
# Argument parsing
#

# Error during argument processing?
argError=0

# Need help?
showHelp=0

# AWS command and subcommand. These are expected before any dashed options.
if ! ( (( $# >= 2 )) && [[ $1 =~ ^[a-z] ]] && [[ $2 =~ ^[a-z] ]] ); then
    echo 1>&2 'Missing AWS command and/or subcommand.'
    argError=1
else
    command="$1"
    subcommand="$2"
    shift 2
fi

# Location (region or availability zone).
inLocation=''

# File to print the constructed command to.
printCommandTo=''

# Output style.
outputStyle=normal

# Assignments and expression arguments to use to construct the value to pass to
# the AWS command.
argConstructor=()

# Assignments and expression arguments to use to perform the result
# postprocessing.
resultConstructor=()

# Just print argument "skeleton" ?
skeleton=0

while (( $# > 0 )); do
    case "$1" in
        --in=?*)
            inLocation="${1#*=}"
            ;;
        --print-command-to=?*)
            printCommandTo="${1#*=}"
            ;;
        --skeleton)
            skeleton=1
            ;;
        -h|--help)
            argError=-1 # `-1` suppresses error exit after displaying usage.
            break
            ;;
        --)
            # Explicit end of options
            shift
            break
            ;;
        -?*)
            echo 1>&2 "Unknown option: $1"
            argError=1
            break
            ;;
        *)
            # Non-option argument
            break
            ;;
    esac

    shift
done

if (( !argError )); then
    if [[ ${inLocation} == '' ]] && (( !skeleton )); then
        echo 1>&2 'Missing option: --in'
        argError=1
    fi
fi

# "Parse" constructor arguments.
while (( $# > 0 && !argError )); do
    arg="$1"
    if [[ ${arg} == '::' ]]; then
        shift
        break
    fi

    argConstructor+=("${arg}")
    shift
done

# Process postprocessor arguments, if any.

while (( $# > 0 && !argError )); do
    case "$1" in
        --compact)
            outputStyle=compact
            ;;
        --none)
            outputStyle=none
            ;;
        --raw)
            outputStyle=raw
            ;;
        --)
            # Explicit end of options
            shift
            break
            ;;
        -?*)
            echo 1>&2 "Unknown option: $1"
            argError=1
            break
            ;;
        *)
            # Non-option argument
            break
            ;;
    esac

    shift
done

resultConstructor=("$@")

if (( argError )); then
    echo 'Usage:'
    echo ''
    echo "${progName} <cmd> <subcommand> [<opt> ...] [--] [<assignment> ...]"
    echo '  [<jq-expression> ...]'
    echo '  [:: [<out-opt> ...] [<assignment> ...] <jq-expression> ...]'
    echo ''
    echo 'Makes an AWS call with a JSON value constructed with `json-val`, and'
    echo 'with successful result optionally post-processed through `json-val`.'
    echo 'If no argument expression is supplied, the value `{}` (an empty object)'
    echo 'is passed to the command. When post-processing, the original result'
    echo 'becomes the sole input from stdin.'
    echo ''
    echo '<cmd> <subcommand>'
    echo '  The AWS command and subcommand to call, e.g. `ec2 run-instances`.'
    echo ''
    echo '--in=<region-or-zone>'
    echo '  What region to make the call in. Must be specified. If specified as'
    echo '  an availability zone, only the region portion matters.'
    echo '--print-command-to=<file>'
    echo '  Name of a file to print the fully-constructed command to. It is'
    echo '  emitted as a JSON value including both split-out components and'
    echo '  the actual commandline.'
    echo '--skeleton'
    echo '  Print out a JSON "skeleton" of parameters. This can be filtered just'
    echo '  like any other result.'
    echo ''
    echo 'Output options:'
    echo ''
    echo '--compact'
    echo '  Output in compact form (not multiline JSON).'
    echo '--none'
    echo '  Do not produce (non-error) output.'
    echo '--raw'
    echo '  Output raw strings (and other values compactly).'
    echo ''
    echo "${progName} [--help | -h]"
    echo '  Displays this message.'
    exit $(( argError < 0 ? 0 : argError ))
fi


#
# Main script
#

dashArgs=(--no-cli-pager --output=json)

if (( skeleton )); then
    dashArgs+=(--generate-cli-skeleton)
else
    inRegion="$(lib region-from-location "${inLocation}")" \
    || exit "$?"
    dashArgs+=(--region="${inRegion}")
fi

jsonArg='{}'
if (( ${#argConstructor[@]} > 0 )); then
    jsonArg="$(jval --compact -- "${argConstructor[@]}")" \
    || {
        echo 1>&2 'Trouble parsing argument constructor.'
        exit 1
    }
fi

# Run the special case handler which manipulates the arguments to `aws`, if such
# a handler is defined (in a sibling file to this script).
specialCaseHandler="${progDir}/${progName}_${command}_${subcommand}"
if [[ -x ${specialCaseHandler} ]]; then
    commandParts="$("${specialCaseHandler}" "$(make-command-parts-json)")" \
    || exit 1

    command="$(jget --raw "${commandParts}" '.command')"
    subcommand="$(jget --raw "${commandParts}" '.subcommand')"
    jsonArg="$(jget --compact "${commandParts}" '.jsonArg')"

    dashArgsLength="$(jget "${commandParts}" '.dashArgs | length')"
    dashArgs=()
    for (( i = 0; i < dashArgsLength; i++ )); do
        dashArgs+=("$(jval --raw p:json="${commandParts}" i:json="${i}" '$p.dashArgs[$i]')")
    done
fi

# Split dash args that use `=` to bind values to instead be separate arguments.
# This is done because, while the AWS CLI nominally recognizes `=` forms, it
# seems to not actually be a well-tested code path. But, because we want the
# special case handlers to have a more standardized setup, we use `=` all the
# way up to this moment. See bug <https://github.com/aws/aws-cli/issues/7058>
# for one way that `=` mis-handling affects things.
origDashArgs=("${dashArgs[@]}")
dashArgs=()
for arg in "${origDashArgs[@]}"; do
    if [[ ${arg} =~ ^--([_a-zA-Z0-9][-_a-zA-Z0-9]+)=([^-].*)?$ ]]; then
        dashArgs+=("--${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}")
    else
        dashArgs+=("${arg}")
    fi
done

# Note: Similarly to above, `--cli-input-json` and its argument are passed as
# separate values, not combined in the usual way with `=`. See the section above
# in re the bug which motivated this arrangement.
fullCommand=(
    aws "${command}" "${subcommand}" "${dashArgs[@]}"
        --cli-input-json "${jsonArg}"
)

if [[ ${printCommandTo} != '' ]]; then
    # Print a JSON value representing the command, hopefully covering pretty
    # much every bit someone might care about.
    jval >"${printCommandTo}" \
        parts:json="$(make-command-parts-json)" \
        full:json="$(jarray --strings "${fullCommand[@]}")" \
        '
        def quoteMaybe:
            if test("^[-_/=a-zA-Z0-9]+$")
            then .
            else (. | @sh)
            end
        ;

        $parts + {
            commandWords: $full,
            commandLine: ($full | map(quoteMaybe) | join(" "))
        }
        '
fi

result="$("${fullCommand[@]}")" \
|| {
    echo 1>&2 'Trouble running AWS command.'
    exit 1
}

# Note: Even if there's no result filter, we use `jget` to automatically get
# color output when appropriate and to do "raw" output when requested.

if (( ${#resultConstructor[@]} == 0 )); then
    resultConstructor=('.')
fi

if [[ ${outputStyle} != 'none' ]]; then
    jgetOpts=()
    case "${outputStyle}" in
        compact)
            jgetOpts+=('--compact')
            ;;
        raw)
            jgetOpts+=('--raw')
            ;;
    esac

    jget "${jgetOpts[@]}" -- "${result}" "${resultConstructor[@]}" \
    || {
        echo 1>&2 'Trouble filtering result.'
        exit 1
    }
fi
