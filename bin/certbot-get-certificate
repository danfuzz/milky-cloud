#!/bin/bash
#
# Copyright 2022 Dan Bornstein.
# Licensed AS IS and WITHOUT WARRANTY under the Apache License, Version 2.0.
# Details: <http://www.apache.org/licenses/LICENSE-2.0>

# Load the helper libraries.
. "$(dirname "$(readlink -f "$0")")/lib/init.sh" || exit "$?"


#
# Argument parsing
#

function usage {
    print-usage $'
    Usage:

    ${name} [<opt> ...]
      Runs Certbot to get a certificate, without actually installing it. This
      uses the DNS challenge, implemented "manually" here to call out to other
      scripts in this project which use Route53. (Why not use Certbot\'s Route53
      plugin? Because as of this writing, it is easier to reimplement it than to
      get the plugins, because reasons.)

      --dir=<path>
        Directory to use for logs and temporary files. Defaults to `tmp-certbot`
        under the current directory. The directory will be created if it
        doesn\'t exist.
      --domain=<domain-name>
        Domain name to get a certificate for. This is required, and can be
        specified more than once to get multiple certificates.
      --email=<email-address>
        Email address to use when making API requests. This is required. Per
        Certbot / LetsEncrypt docs, this is just used for urgent communication.
      --staging
        Use the staging server.

    ${name} [--help | -h]
      Displays this message.
    '

    exit "$@"
}

# Special logic for callbacks from `certbot` to skip the usual argument parsing
# and just call the right hook.
runHook=''
if [[ ${RUN_CERTBOT_HOOK} == 1 ]]; then
    # Certbot sets `CERTBOT_AUTH_OUTPUT` only when calling the cleanup script.
    if [[ ${CERTBOT_AUTH_OUTPUT-unset} == 'unset' ]]; then
        runHook=authentication
    else
        runHook=cleanup
    fi
fi

if [[ ${runHook} == '' ]]; then
    # Want help?
    opt-action --call='{ usage }' help/h

    # Directory to use.
    opt-value --var=dir --init='./tmp-certbot' dir

    # Site to get a certificate for.
    domainArgs=()
    opt-value --required --call=add-domain --filter='/^([*][.])?[-.a-z0-9]+$/' domain
    function add-domain {
        domainArgs+=(--domain="$1")
    }

    # Email address.
    opt-value --required --var=email --filter='/^[-_.+@a-z0-9]+$/' email

    # Use the staging server?
    opt-toggle --var=useStaging staging

    process-args "$@" || usage "$?"
fi


#
# Helper functions
#

# The "authentication" hook. This is (in effect) a callback from `certbot`.
function authentication-hook {
    info-msg '####### AUTHENTICATION HOOK CALLED'
    env | grep CERTBOT | info-msg --exec cat
    info-msg

    local validationData="${CERTBOT_VALIDATION}"
    local domain="${CERTBOT_DOMAIN}"

    local payload="$(make-change-payload CREATE "${domain}" "${validationData}")"

    echo '############## PAYLOAD'
    jval "${payload}"
    echo '############## END PAYLOAD'

    lib aws-json route53 change-resource-record-sets --global \
        zoneId="${zoneId}" \
        payload:json="${payload}" \
        '{
            HostedZoneId: $zoneId,
            ChangeBatch: $payload
        }'

    # TODO: Use `route53 get-change` to figure out when the record is ready.

    info-msg '####### AUTHENTICATION HOOK DONE'

    exit 1
}

# The "cleanup" hook. This is (in effect) a callback from `certbot`.
function cleanup-hook {
    echo '####### CLEANUP HOOK CALLED'
    #env | grep CERTBOT | info-msg --exec cat

    local domain="${CERTBOT_DOMAIN}"
    local remainingChallenges="${CERTBOT_REMAINING_CHALLENGES}"
    local validationData="${CERTBOT_VALIDATION}"

    local zoneId
    zoneId="$(find-zone-id "${domain}")" \
    || return "$?"

    local payload="$(make-change-payload DELETE "${domain}" "${validationData}")"

    local error
    lib aws-json route53 change-resource-record-sets --global \
        zoneId="${zoneId}" \
        payload:json="${payload}" \
        '{
            HostedZoneId: $zoneId,
            ChangeBatch: $payload
        }'
    error="$?"

    if [[ ${remainingChallenges} == 0 ]]; then
        # No more challenges. Do the "extra cleanup" work.
        extra-cleanup || return "$?"
    fi

    echo '####### CLEANUP HOOK DONE'
    return "${error}"
}

# "Extra clean" cleanup hook: Remove any stray records leftover from old
# Certbot requests.
function extra-cleanup {
    local allDomains="${CERTBOT_ALL_DOMAINS}"
    allDomains=($(
        tr <<<"${allDomains}" ',' '\n' \
        | awk '
            /[.].*[.]/ { $0 = substr($0, match($0, /[^.]*[.][^.]*$/)) }
            { print }
        ' \
        | sort -u
    ))

    local domain zoneId
    for domain in "${allDomains[@]}"; do
        zoneId="$(find-zone-id "${domain}")" \
        || return "$?"

        local payload
        payload="$(lib aws-json route53 list-resource-record-sets --global \
            zoneId="${zoneId}" \
            '{ HostedZoneId: $zoneId }' \
            :: '
              .ResourceRecordSets
            | map(select(.Type == "TXT"))
            | map(select(.Name | test("^_acme-challenge[.]")))
            |
            if length > 0
            then {
              Comment: "Via Cerbot wrapper extra-cleanup script",
              Changes: map({
                Action: "DELETE",
                ResourceRecordSet: .
              })
            }
            else null
            end
            '
        )" \
        || return "$?"

        if [[ ${payload} != 'null' ]]; then
            echo "Cleaning up leftover challenges for domain: ${domain}"
            lib aws-json route53 change-resource-record-sets --global \
                zoneId="${zoneId}" \
                payload:json="${payload}" \
                '{
                    HostedZoneId: $zoneId,
                    ChangeBatch: $payload
                }' \
            || return "$?"
        fi
    done
}

# Finds the zone ID for a given domain name.
function find-zone-id {
    local domain="$1"

    # Extract the main domain, and append `.` to make it officially "absolute."
    [[ ${domain} =~ [^.]+[.][^.]+$ ]] || return "$1"
    domain="${BASH_REMATCH[0]}."

    local zoneId
    zoneId="$(
        lib aws-json route53 list-hosted-zones --global :: --output=raw \
            domain="${domain}" \
            '.HostedZones[] | select(.Name == $domain) | .Id'
    )" \
    || return "$?"

    if [[ ${zoneId} == '' ]]; then
        error-msg "Could not find zone ID for domain: ${domain}"
        return 1
    fi

    echo "${zoneId}"
}

# Makes a payload for a DNS change request.
function make-change-payload {
    local action="$1"
    local domain="$2"
    local data="$3"

    # Note: The Route53 API requires the `Value` passed in for a `TXT` record to
    # be surrounded by double quotes (for an at least _somewhat_ okay reason),
    # hence the `| @json` below.
    jval \
        action="${action}" \
        name="_acme-challenge.${domain}." \
        data="${validationData}" \
    '{
        Comment: "Via Certbot wrapper script",
        Changes: [
            {
                Action: $action,
                ResourceRecordSet: {
                    Name: $name,
                    Type: "TXT",
                    TTL: 60,
                    ResourceRecords: [{ Value: ($data | @json) }]
                }
            }
        ]
    }'
}


#
# Main script
#

# Just run the requested callback hook, if it looks like we were called from
# Certbot.
if [[ ${runHook} != '' ]]; then
    "${runHook}-hook"
    exit "$?"
fi

# Not a callback. Do the main call.

if [[ ! -d "${dir}" ]]; then
    mkdir -p "${dir}" || exit "$?"
fi

extraOpts=()
if (( useStaging )); then
    extraOpts+=(--staging)
fi

thisCmd="$(this-cmd-path)"
RUN_CERTBOT_HOOK=1 \
certbot certonly \
    --config-dir="${dir}" --logs-dir="${dir}" --work-dir="${dir}" \
    --manual --noninteractive --agree-tos --email="${email}" \
    --preferred-challenges=dns \
    --manual-auth-hook="${thisCmd}" --manual-cleanup-hook="${thisCmd}" \
    "${extraOpts[@]}" "${domainArgs[@]}"
