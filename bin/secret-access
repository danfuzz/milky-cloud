#!/bin/bash
#
# Copyright 2022 Dan Bornstein.
# Licensed AS IS and WITHOUT WARRANTY under the Apache License, Version 2.0.
# Details: <http://www.apache.org/licenses/LICENSE-2.0>

# Load the helper libraries.
. "$(dirname "$(readlink -f "$0")")/lib/init.sh" || exit "$?"

#
# Argument parsing
#

function usage {
    print-usage $'
    Usage:

    ${name} [<opt> ...] <assignment> ...
      Access account secrets. This is a wrapper for 1Password\'s `op` tool (and
      may eventually grow to handle other things), meant to avoid tainting the
      rest of the system with details of how secrets are retrieved.

      The <assignment> syntax is `<name>=<path>` where `name` is the name to
      assign, and `path` is the URI-like path to the secret in whatever container
      it comes from. Alternatively, the form `<name>` (no `=` or right-hand-side)
      is short for `<name>=<name>`.

    --output=<style>
      `eval` -- Output an `eval`able script to set the values.
      `json` -- Output a JSON object with bindings for all requested secrets.
        This is the default.
    --source=<origin>
      Container to retrieve from. This is required.
      `1password:<vault>/<record>` -- Names a 1Password vault and record to
        retrieve from. The path can be arbitrarily deep.
      (other sources may be defined later)

    ${name} [--help | -h]
      Displays this message.
    '

    exit "$@"
}

# Want help?
opt-action --call='{ usage }' help/h

opt-value --var=outputStyle --init='json' --enum='eval json' output

opt-value --required --var=source --filter='/^[a-z0-9]+:[-_/a-zA-Z0-9]+$/' source

# List of variable assignments, as parallel arrays of name and value.
varNames=()
varValues=()

rest-arg --call=parse-rest --filter='/^[_a-zA-Z0-9]+(=[-_.:/a-zA-Z0-9]+)?$/' assignments
function parse-rest {
    if (( $# == 0 )); then
        error-msg 'Need one or more assignment arguments.'
        return 1
    fi

    # Parse assignments.
    while (( $# > 0 )); do
        local arg="$1"

        [[ ${arg} =~ ^([^=]+)(=(.*))?$ ]] \
        || break

        local name="${BASH_REMATCH[1]}"
        local value="${BASH_REMATCH[3]}"

        if [[ ${value} == '' ]]; then
            value="${name}"
        fi

        varNames+=("${name}")
        varValues+=("${value}")
        shift
    done
}

process-args "$@" || usage "$?"


#
# Helper functions
#

# Retrieves a secret from 1Password.
function source-1password {
    local vaultRecord="$1"
    local path="$2"

    # Note: `op` is the (very poorly named) 1Password CLI.
    op read "op://${vaultRecord}/${path}"
}


#
# Main script
#

if ! [[ ${source} =~ ^([^:]+):(.*)$ ]]; then
    error-msg "Invalid source: ${source}"
    exit 1
fi
sourceType="${BASH_REMATCH[1]}"
sourcePath="${BASH_REMATCH[2]}"

sourceFunc="source-${sourceType}"
if ! declare -F "${sourceFunc}" >/dev/null; then
    error-msg "Unrecognized source: ${sourceType}"
    exit 1
fi

for (( i = 0; i < ${#varNames[@]}; i++ )); do
    value="${varValues[${i}]}"
    value="$("${sourceFunc}" "${sourcePath}" "${value}")" \
    || exit "$?"
    varValues[${i}]="${value}"
done

case "${outputStyle}" in
    eval)
        for (( i = 0; i < ${#varNames[@]}; i++ )); do
            name="${varNames[${i}]}"
            value="${varValues[${i}]}"
            printf 'export %s=%q\n' "${name}" "${value}"
        done
        ;;
    json)
        jval \
            names:json="$(jarray --input=strings "${varNames[@]}")" \
            values:json="$(jarray --input=strings "${varValues[@]}")" '
            [$names, $values]
            |
            transpose
            |
            map({ key: .[0], value: .[1] })
            |
            from_entries
            '
        ;;
esac
