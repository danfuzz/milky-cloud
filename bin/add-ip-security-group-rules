#!/bin/bash
#
# Copyright 2022 Dan Bornstein.
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

# Figure out the symlink-resolved program name and directory.
progName="$(readlink -f "$0")" || exit "$?"
progDir="${progName%/*}"
progName="${progName##*/}"

# Load the helper library.
. "${progDir}/lib/init"


#
# Argument parsing
#

function usage {
    print-usage $'
    Usage:
    
    ${name} [<opt> ...]
      Adds one or more rules to a given security group to specify IP-based
      restrictions. Either `--port` or `--all-ports` must be passed. Similarly,
      one protocol option must be passed. Upon success, prints out a JSON
      array of all added rules.
    
      Note: Even though this command only nominally lets you specify one
      rule, AWS splits out multiple rules when the specified rule applies
      to multiple IP address ranges (including notably treating "any IPv4"
      and "any IPv6" as different ranges).
    
      --all-ports
        The rule is to apply to all ports.
      --all-protocols
        The rule is to apply to all protocols.
      --egress
        The rule is to be an egress rule.
      --in=<region-or-zone>
        What region to make the security group in. Must be specified. If
        specified as an availability zone, only the region portion matters.
      --ingress
        The rule is to be an ingress rule.
      --name=<name>
        Name to attach to the rule, if any.
      --port=<number>
        Port for the rule.
      --quiet
        Suppress non-error output.
      --security-group=<name-or-id>
        Name or ID of the security group to add to. Can also be a VPC ID,
        to indicate the default security group for that VPC.
      --tcp
        The rule is for TCP traffic.
      --udp
        The rule is for UDP traffic.
    
    ${name} [--help | -h]
      Displays this message.
    '

    exit "$1"
}

# Error during argument processing?
argError=0

# Rule direction (`ingress` or `egress`).
direction=''

# Name or ID of the security group.
groupNameOrId=''

# Location (region or availability zone).
inLocation=''

# Name of the rule.
name=''

# Port of the rule.
port=''

# Protocol of the rule.
protocol=''

# Quiet?
quiet=0

while (( $# > 0 )); do
    case "$1" in
        --all-ports)
            port='all'
            ;;
        --all-protocols)
            protocol='all'
            ;;
        --egress)
            direction='egress'
            ;;
        --in=?*)
            inLocation="${1#*=}"
            ;;
        --ingress)
            direction='ingress'
            ;;
        --name=?*)
            name="${1#*=}"
            ;;
        --port=?*)
            port="${1#*=}"
            ;;
        --quiet)
            quiet=1
            ;;
        --security-group=?*)
            groupNameOrId="${1#*=}"
            ;;
        --tcp)
            protocol='tcp'
            ;;
        --udp)
            protocol='udp'
            ;;
        -h|--help)
            argError=-1 # `-1` suppresses error exit after displaying usage.
            break
            ;;
        --)
            # Explicit end of options.
            shift
            break
            ;;
        -?*)
            echo 1>&2 "Unknown option: $1"
            argError=1
            break
            ;;
        *)
            # Non-option argument.
            break
            ;;
    esac

    shift
done

if (( !argError )); then
    if [[ ${inLocation} == '' ]]; then
        echo 1>&2 'Missing option: --in'
        argError=1
    fi
    if [[ ${groupNameOrId} == '' ]]; then
        echo 1>&2 'Missing option: --security-group'
        argError=1
    fi
    if [[ ${direction} == '' ]]; then
        echo 1>&2 'Missing option: --egress or --ingress'
        argError=1
    fi
    if [[ ${port} == '' ]]; then
        echo 1>&2 'Missing option: --all-ports or --port'
        argError=1
    fi
    if [[ ${protocol} == '' ]]; then
        echo 1>&2 'Missing option: --all-protocols, --tcp, or --udp'
        argError=1
    fi
fi

if (( argError )); then
    usage "${argError}"
fi


#
# Main script
#

inRegion="$(lib region-from-location "${inLocation}")" \
|| exit "$?"

# Validate or find the ID of the security group.
groupId="$(lib find-security-group --in="${inRegion}" "${groupNameOrId}")" \
|| exit "$?"

tagSpec='{}'
if [[ ${name} != '' ]]; then
    tagSpec="$(lib name-tag-spec 'security-group-rule' "${name}")"
fi

command="authorize-security-group-${direction}"

ipSpec="$(lib ip-permission-spec "${protocol}" "${port}")" \
|| exit "$?"

filterArg='.SecurityGroupRules | map(.SecurityGroupRuleId)'
if (( quiet )); then
    filterArg='--none'
fi

ec2-json "${command}" \
    --in="${inRegion}" \
    groupId="${groupId}" \
    ipPermissions:json="[${ipSpec}]" \
    tagSpec:json="${tagSpec}" \
    '
    $tagSpec +
    {
        GroupId: $groupId,
        IpPermissions: $ipPermissions
    }' \
    :: "${filterArg}"
